\chapter{Implementierung}
\label{chap:Implementierung}

\section{Editor}
\label{sec:Editor}
Der Editor ist die Schnittstelle der DSL mit einem menschlichen Benutzer. Hier wird ein DSL-Modell durch Interaktion mit der konkreten Syntax erstellt oder bearbeitet. Die konkrete Syntax nimmt die Form eines Graphen an, der in Kapitel \ref{chap:Einleitung} beschrieben ist. Die Aufgabe des Editors ist es, die konkrete Syntax in abstrakte Syntax umzuwandeln. Während der Benutzer über die grafische Benutzeroberfläche mit der konkreten Syntax interagiert, also Instruktionen hinzufügt und Verbindungen zieht, wird Editor-intern die abstrakte Syntax geformt, welche der Benutzer nicht sieht (vgl. [CITATION Voelter, DSL Engineering, Abs 3.4, PDF Seite 68]. Die abstrakte Syntax ist durch eine C\#-Datenstruktur repräsentiert, welche für die weiteren Verarbeitungsschritte gespeichert wird (siehe Abschnitt \ref{sec:Verarbeitungsschritte}). In der Literatur wird die Datenstruktur, welche die abstrakte Syntax beinhaltet, auch semantisches Modell (engl. semantic model) genannt, vgl. [CITATION Martin Fowler, Domain Specific Languages] und wird daher im Folgenden auch so referenziert. Der Editor bildet also die abstrakte Syntax auf das semantische Modell ab. Diese Abbildung ist bidirektional: Wird das semantische Modell manipuliert, spiegelt die grafische Benutzeroberfläche dies in der konkreten Syntax wider.
\newline
Der Editor ist als eine Windows Forms-Anwendung umgesetzt und implementiert das Model-View-Viewmodel-Entwicklungsmuster (kurz MVVM). Ähnlich wie bei verwandten Entwurfsmustern wie zum Beispiel Model-View-Controller (MVC) geht es bei MVVM darum, die Darstellung einer Anwendung von ihrer Logik zu trennen. Dies geschieht durch eine Einteilung in drei verschiedene Schichten: Dem View, dem Viewmodel und dem Model. Die View-Schicht dient zur Darstellung der Anwendung und umfasst die Komponenten der grafischen Benutzeroberfläche. Sie erhält die nötigen Daten zur Darstellung vom Viewmodel über sogenannte Datenbindung (engl. Data Binding). Dabei werden Daten über ein Framework an einander gebunden und werden so vom System bei jeder Zustandsänderung synchron gehalten. Ändern sich also Daten im Viewmodel wird dies unverzüglich im View angezeigt. Das Viewmodel kümmert sich um die Präsentationslogik, das heißt es ist dafür zuständig, dem View Daten zur Verfügung zu stellen, welche über Datenbindungen angezeigt werden sollen. Dafür hat das Viewmodel Zugriff auf das Model, über dass die Daten zur Darstellung abgerufen werden. Im Model werden auch die Geschäftslogik sowie Speicher- und Lade-Aktionen ausgeführt. In .NET wird MVVM vor allem im Zuge der Windows Presentation Foundation eingesetzt, kann aber auch durch das Devexpress-Framework in Windows Forms-Anwendungen benutzt werden.
\newline
Im grafischen Editor der DSL werden die drei Schichten von MVVM durch verschiedene C\#-Klassen abgebildet, welche im Folgenden erläutert werden.
\subsection{Die Model-Schicht: Flow, Node, Input, Output, Connector, Variable, Function}
Die Model-Schicht beinhaltet die C\#-Datenstruktur, welche auch als semantisches Modell bezeichnet wird: Also das Objekt, welches in der weiteren Verarbeitung die abstrakte Syntax beschreibt. Das semantische Modell selbst weist kein programmitisches Verhalten auf, sondern ist eine reine Datenstruktur. Es besteht aus Instanzen von Klassen, welche die einzelnen Elemente der DSL modellieren und im Namespace ilogixx.ConversationFlow.Core definiert sind. Die Klassenstruktur der Model-Schicht ist in Abbildung [IMAGE UML MODEL] als UML-Diagramm aufgeführt und wird im Folgenden erläutert.
\newline
Instruktionen werden durch die abstrakte Klasse Node modelliert. Node besitzt eine Liste von Referenzen auf Output-Objekte, welche die Ausgänge einer Intruktion modellieren. Node hat ebenfalls eine Referenz auf ein Objekt vom Typ Input, welches den Eingang eines Knotens symbolisiert. Jede Art von Instruktion hat ihre eigene Subklasse, welche die Instruktionen aus Abschnitt \ref{sec:Sprachelemente} abbilden. Pro Ausgang einer Instruktion fügt der Konstruktor des Subtypen eine Referenz vom Typen Output der Referenzliste der Basisklasse hinzu. Im Konstruktor wird ebenfalls der Input spezifiziert: Hat die Instruktion einen Eingang, wird die Input-Referenz instanziert, andernfalls bleibt sie null. Viele Instruktionen haben die gleiche Anzahl an Ausgängen und einen Eingang. Daher existieren Subtypen, welche diese Initialisierungsarbeit übernehmen: Inputnode, für Instruktionen die einen Eingang haben, SingleOutputNode für Instruktionen die einen einzelnen Ausgang haben, und SingleThroughputNode, für Instruktionen die einen Ein- und einen einzelnen Ausgang haben. Alle elf Subtypen für die Instruktionen erben von diesen drei Klassen und passen dort wo nötig ihre Konfiguration an. Beispielsweise erbt DTMFCharacterNode von InputNode, und fügt der Output-Referenzliste dreizehn neue Outputs hinzu.
\newline
Die Klasse Input ist simpel: Sie zeigt über eine Referenz vom Typen Node auf ihre besitzende Instruktion. Die Klasse Output hingegen besitzt einige mehrere Daten. Sie speichert den Bezeichner des Ausgangs als String, einen weiteren String namens DisplayString, welcher vom Benutzer editiert werden kann und auf der Benutzeroberfläche angezeigt wird, einen Boolean namens Visible, welcher bestimmt ob der Ausgang in dem Rechteck der beinhaltenden Instruktion angezeigt wird, und eine Referenz vom Typ Input auf einen Eingang, falls der Ausgang mit einem solchen verbunden sein sollte. Durch letztere Input-Referenz sind die Verbindungen im Konversationsrouting zwischen den Instruktionen implizit gegeben. Dennoch existiert eine weitere Klasse namens Connector, welche eine Verbindung explizit definiert. Sie besitzt Referenzen auf die Input- und die Output-Instanz, welche verbunden sind.
\newline
Benutzerdefinierte Variablen und Funktionen sind über eigene Klassen abgebildet: Variable und Function. Variable besitzen einen Namen vom Typen String und einen Typen, der über einen Enum namens VariableType abgebildet ist, welcher die in \ref{subsec:Variablen} aufgezählten Typen beinhaltet. Function speichert ebenfalls einen Namen vom Typen String und einen Rückgabetyp, welcher über einen Enum mit Namen FunctionReturnType abgebildet ist. Zusätzlich wird der Funktionskörper mit Namen Body als String gespeichert. Parameter einer Funktion werden über eine Liste von Referenzen auf Objekte des Type Parameter modelliert. Ein Parameter besitzt, ähnlich wie die Klasse Variable, einen Namen als String und einen Typen als VariableType. 

\subsection{Die Viewmodel-Schicht: FlowDiagramViewmodel}
TODO

\subsection{Die View-Schicht: FlowDiagramView, FlowDiagramControl, FlowDiagramItem}
FlowDiagramControl kümmert sich um die unmittelbare Darstellung der abstrakten Syntax auf der grafischen Benutzeroberfläche. Es basiert auf der Devexpress-Klasse DiagramControl, welche es Benutzer ermöglicht, Diagramme mit geometrischen Formen und Verbindungen zu gestalten. FlowDiagramControl ist von der Klasse DiagramControl abgeleitet und erweitert diese um Möglichkeiten, die DSL per Datenbindung darzustellen. Dafür sind in FlowDiagramControl Listen vom .NET-Typ ObservableCollection hinzugefügt, welche die Elemente des aktuellen DSL-Modells enthalten. Diese Listen werden gepflegt, indem FlowDiagramControl auf Events der Basisklasse DiagramControl reagiert.  
 

\section{Code-Generierung}
\label{sec:Code-Generierung}
TODO

\subsection{Herausforderungen}
TODO

\subsubsection{Programmablauf}
TODO

\subsubsection{User-Code}
TODO

\subsubsection{Nebenläufigkeit}
TODO

\subsection{Algorithmus}
TODO

\subsection{Einbindung von generiertem Code}
TODO