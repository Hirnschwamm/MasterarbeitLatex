\chapter{Implementierung}
\label{chap:Implementierung}

\section{Editor}
\label{sec:Editor}
Der Editor ist die Schnittstelle zwischen der DSL und einem menschlichen Benutzer. Hier wird ein DSL-Modell durch Interaktion mit der konkreten Syntax erstellt oder bearbeitet. Die konkrete Syntax nimmt die Form eines Graphen an, der in Kapitel \ref{chap:Einleitung} beschrieben ist. Mit dem Editor kann dieser Graph über die grafische Benutzeroberfläche in die gewünschte Form gebracht werden. Abbildung \ref{fig:EditorGUI} zeigt und erklärt die Komponenten der grafischen Benutzeroberfläche.
\newline 
Neben der Interaktion mit dem Benutzer ist die andere Aufgabe des Editors, die konkrete Syntax in abstrakte Syntax umzuwandeln. Während der Benutzer über die grafische Benutzeroberfläche mit der konkreten Syntax interagiert, also Instruktionen hinzufügt und Verbindungen zieht, wird Editor-intern die für den Benutzer unsichtbare abstrakte Syntax geformt. Die abstrakte Syntax ist durch eine C\#-Datenstruktur repräsentiert, welche für die weiteren Verarbeitungsschritte gespeichert wird (siehe Abschnitt \ref{sec:Verarbeitungsschritte}). In der Literatur wird die Datenstruktur, welche die abstrakte Syntax beinhaltet, auch semantisches Modell (engl. semantic model) genannt (vgl. \cite[S. 16ff]{Fowler:11}), und wird daher im Folgenden auch so betitelt. Der Editor bildet also die konkrete Syntax auf das semantische Modell ab. Diese Abbildung ist bidirektional: Änderungen am semantischen Modell spiegelt die grafische Benutzeroberfläche in der konkreten Syntax wider. 
\newline
Der Editor ist als eine Windows Forms-Anwendung umgesetzt und implementiert das Model-View-Viewmodel-Entwicklungsmuster (kurz MVVM). Ähnlich wie bei verwandten Entwurfsmustern wie zum Beispiel Model-View-Controller (MVC) geht es bei MVVM darum, die Darstellung einer Anwendung von ihrer Logik zu trennen. Dies geschieht durch eine Einteilung in drei verschiedene Schichten: Dem View, dem Viewmodel und dem Model. Die View-Schicht dient zur Darstellung der Anwendung und umfasst die Komponenten der grafischen Benutzeroberfläche. Sie erhält die nötigen Daten zur Darstellung vom Viewmodel über sogenannte Datenbindung (engl. Data Binding). Dabei werden Daten über ein Framework an einander gebunden und werden so vom System bei jeder Zustandsänderung synchronisiert. Ändern sich also Daten im Viewmodel wird dies unverzüglich im View angezeigt. Das Viewmodel kümmert sich um die Präsentationslogik. Das heißt es ist dafür zuständig Daten so aufzubereiten, dass diese dem View per Datenbindung zur Verfügung gestellt werden können. Dafür hat das Viewmodel Zugriff auf das Model, welches die Daten speichert. Im Viewmodel wird auch die Geschäftslogik sowie Speicher- und Lade-Aktionen ausgeführt. In .NET wird MVVM vor allem im Zuge der Windows Presentation Foundation eingesetzt, kann aber durch das Devexpress-Framework auch in Windows Forms-Anwendungen benutzt werden. 
\newline
Im grafischen Editor der DSL werden die drei Schichten von MVVM durch verschiedene C\#-Klassen abgebildet, welche im Folgenden erläutert werden.

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/EditorGUI.png}
    \captionsetup{singlelinecheck=off}
	\caption[Die Benutzeroberfläche des Editors]
	{
	\label{fig:EditorGUI}
	Zu sehen ist die Benutzeroberfläche des Editors. Die Nummerierung beziffert folgende Komponenten:
	\begin{enumerate}
	\item Menüleiste. Hier kann der Benutzer Routings speichern oder laden, sowie das Verbindungswerkzeug zum Verbinden von zwei Instruktionen an- und ausschalten.
	\item Instruktionsauswahl-Fenster. Der Benutzer sieht hier eine Übersicht der verfügbaren Instruktionen. Per "Drag and Drop" kann er eine Instruktion auswählen und in das Editor-Fenster ziehen.
	\item Editor-Fenster. Hier kann der Benutzer das Konversationsrouting modellieren, indem er Instruktionen hinzufügt, löscht, anordnet und miteinander verbindet.
	\item Ausdruck-Editor. Der Editor ist in dieser Darstellung stellvertretend für alle Editoren dargestellt, die sich in einem weiteren Fenster öffnen. In diesem Fall ist der Ausdruck-Editor geöffnet, da momentan der boolesche Ausdruck für die Branch-Instruktion editiert wird. Hier kann der Benutzer seinen eigenen Code schreiben. Der Editor verfügt über ein eigenes Diagnose-Fenster, in dem Fehlermeldungen dargestellt werden, die sich auf den zu editierenden Code beziehen.
	\item Diagnose-Fenster. Hier werden alle Fehlermeldungen aufgelistet, die durch die Modell-Validierung detektiert werden. Bei Fehlermeldungen, die sich explizit auf eine Instruktion beziehen, werden diese Instruktionen rot umrandet. Durch einen Doppelklick auf eine Fehlermeldung wird die betroffene Instruktion ausgewählt, oder falls nötig, ein Editor geöffnet der den fehlerhaften Code darstellt.
	\item Parameter-Fenster. Hier können die Parameter der aktuell ausgewählten Instruktion angepasst werden. Ist keine Instruktion ausgewählt, können die weiteren Eigenschaften des Konversationsroutings eingestellt werden, wie zum Beispiel benutzerdefinierte Variablen und Funktionen.
 	\end{enumerate}
 	}
\end{figure}


\subsection[Die Model-Schicht]{Die Model-Schicht: Flow, Node, Input, Output, Connector, Variable, Function}
\label{subsec:Die Model-Schicht}
Die Model-Schicht beinhaltet die C\#-Datenstruktur, welche als semantisches Modell bezeichnet wird. Es handelt sich um das Objekt, welches in der weiteren Verarbeitung die abstrakte Syntax beschreibt. Das semantische Modell selbst weist kein programmatisches Verhalten auf, sondern ist eine reine Datenstruktur. Es besteht aus Instanzen von Klassen, welche die einzelnen Elemente der DSL modellieren und im Namespace ilogixx.ConversationFlow.Core definiert sind. Die Klassenstruktur der Model-Schicht ist in Abbildung \ref{fig:UML:Model-Schicht} als UML-Diagramm aufgeführt.
\newline
Instruktionen werden durch die abstrakte Klasse Node modelliert. Node besitzt eine Liste von Referenzen auf Output-Objekte, welche die Ausgänge einer Instruktion modellieren. Node hat ebenfalls eine Referenz auf ein Objekt vom Typ Input, welches den Eingang eines Knotens symbolisiert. Jede Art von Instruktion hat ihre eigene Subklasse, dargestellt in Abb. \ref{fig:UML:Node-Hierarchy}, welche die Instruktionen aus Abschnitt \ref{sec:Sprachelemente} abbilden. Pro Ausgang einer Instruktion fügt der Konstruktor des entsprechenden Subtypen der Referenzliste der Basisklasse eine neue Referenz vom Typen Output hinzu. Im Konstruktor wird ebenfalls der Input spezifiziert: Hat die Instruktion einen Eingang, wird die Input-Referenz instanziert, andernfalls bleibt sie null. Viele Instruktionen haben die gleiche Anzahl an Ausgängen und einen Eingang. Daher existieren zusätzliche Subtypen, welche die Initialisierungsarbeit übernehmen: Inputnode für Instruktionen, die einen Eingang haben, SingleOutputNode für Instruktionen, die einen einzelnen Ausgang haben und SingleThroughputNode für Instruktionen, die einen Ein- und einen einzelnen Ausgang haben. Alle dreizehn Subtypen für die Instruktionen erben von diesen drei Klassen und passen dort wo nötig ihre Input- und Output-Konfiguration an. Beispielsweise erbt DTMFCharacterNode von InputNode und fügt der Output-Referenzliste dreizehn neue Outputs hinzu.
\newline
Die Klasse Input ist simpel: Sie zeigt über eine Referenz vom Typen Node auf ihre besitzende Instruktion. Die Klasse Output hingegen besitzt einige mehrere Daten. Sie speichert den Bezeichner des Ausgangs als String, einen weiteren String namens DisplayString, welcher vom Benutzer editiert werden kann und auf der Benutzeroberfläche angezeigt wird, einen Boolean namens Visible, welcher bestimmt ob der Ausgang in dem Rechteck der beinhaltenden Instruktion angezeigt wird, und eine Referenz vom Typ Input auf einen Eingang, falls der Ausgang mit einem solchen verbunden sein sollte. Durch letztere Input-Referenz sind die Verbindungen im Konversationsrouting zwischen den Instruktionen implizit gegeben. Zusätzlich existiert eine weitere Klasse namens Connector, welche eine Verbindung explizit definiert. Sie besitzt Referenzen auf diejenigen Input- und die Output-Instanzen, welche in einem Konversationrouting verbunden sind.
\newline
Benutzerdefinierte Variablen und Funktionen sind über die eigenen Klassen Variable und Function abgebildet. Variable besitzt einen Namen vom Typ String und einen Typ, der über einen Enum namens VariableType modelliert ist. Dieser Enum beinhaltet die in \ref{subsec:Variablen} aufgezählten Typen. Function speichert ebenfalls einen Namen vom Typ String und einen Rückgabetyp, welcher über einen Enum mit Namen FunctionReturnType abgebildet ist. Zusätzlich wird der Funktionskörper mit Namen Body als String gespeichert. Die Parameter einer Funktion werden über eine Liste von Referenzen auf Objekte des der eigenen Klasse Parameter modelliert. Ein Parameter besitzt, ähnlich wie die Klasse Variable, einen Namen als String und einen Typ als VariableType. Die Klasse Flow vereint alle oben genannten Klassen: Sie beinhaltet Listen mit Referenzen auf alle Nodes, Connectors, Functions und Variables eines Konversationsroutings. 

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/FlowClassStructure.png}
	\caption[Klassenstruktur der Model-Schicht]{Zu sehen ist ein Teil der Klassenstruktur der Model-Schicht. Diese ist zugleich auch das semantische Modell, welches in weiteren Verarbeitungsschritten übergeben wird.}
	\label{fig:UML:Model-Schicht}
\end{figure}

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/NodeHierarchy.png}
	\caption[Klassenhierarchie der Klasse Node]{Abgebildet ist die Klasse Node und ihre Subtypen. Jede Instruktion der DSL ist durch einen Subtyp von Node abgebildet. Ob die Klasse als Zwischenstufe von InputNode, SingleThroughputNode oder SingleOutputNode erbt, ergibt sich aus der Anzahl an Inputs und Outputs der Instruktion.}
	\label{fig:UML:Node-Hierarchy}
\end{figure}

\subsection[Die Viewmodel-Schicht]{Die Viewmodel-Schicht: FlowDiagramViewmodel, CodeEditorViewModel, FunctionCollectionEditorViewModel}
\label{subsec:Die Viewmodel-Schicht}
In der Viewmodel-Schicht werden die Klasseninstanzen der Model-Schicht so aufbereitet, dass die View-Schicht sie per Datenbindung repräsentieren kann. Die Viewmodel-Schicht reagiert auch auf Eingaben des Benutzers und manipuliert das zu Grunde liegende Model nach dessen Wünschen. Der wichtigste Teil der Viewmodel-Schicht ist in Abbildung \ref{fig:UML:FlowViewModel} dargestellt.  
\newline
Der Hauptbestandteil der Schicht ist die Klasse FlowDiagramViewmodel. Diese besitzt als Member-Variablen Listen auf Referenzen der Model-Komponenten Node, Connector, Variable und Function. Diese Listen sind vom .NET-Typ ObservableCollection, welcher ein Event auslöst, falls Objekte hinzugefügt oder entfernt werden und sind per Devexpress-Datenbindung an die View-Schicht gekoppelt. Das heißt, wenn auf der View-Schicht Elemente des Modells wie zum Beispiel neue Node- oder Connector-Objekte hinzugefügt werden, aktualisieren sich die entsprechenden Listen im FlowDiagramViewmodel. Zusätzlich werden dadurch Events ausgelöst, auf die FlowDiagramViewModel in den Methoden HandleNodesChanged und HandleConnectorsChanged reagiert. Dies wird dazu genutzt, die Referenzen zwischen den Klassen Input und Output aktuell zu halten: Wird ein Connector der Liste hinzugefügt, wird die Input-Referenz des im Connector referenzierten Outputs auf den Input gesetzt, der ebenfalls im Connector verlinkt ist. Der Vorgang wird rückgängig gemacht, wenn ein Connector entfernt wird. Die Datenbindung funktioniert auch umgekehrt: Wenn sich die Input-Referenz eines Outputs ändert, wird ein Event ausgelöst, welches in der Methode HandleOutputPropertyChanged behandelt wird. Dort wird ein neuer Connector mit entsprechenden Input- und Output-Referenzen hinzugefügt. Der grundsätzliche Ablauf der Kommunikation zwischen ViewModel und View ist in Abb. \ref{fig:UML:MVVMSequence} verbildlicht.
\newline 
FlowDiagramViewModel übernimmt mittels der beiden Kommandos WriteToDisk und ReadFromDisk auch das Speichern und Laden von Konversationsroutings. Dafür wird mit den Listen der Node-, Connector-, Variable- und Function-Instanzen ein Flow-Objekt instanziert und mit Protobuf serialisiert. Pfade für die zu schreibenden beziehungsweise lesenden Dateien werden über Dialoge vom Benutzer abgefragt. Die Dialoge werden über vorgefertigte Serviceklassen angezeigt, welche das MVVM-Framework von Devexpress per Dependency Injection zur Verfügung stellt. 
\newline
Einige Instruktionen eines Konversationsroutings benötigen die Möglichkeit, Code einzugeben. Zu diesem Zweck existiert ein weiteres ViewModel, welches dem eingebauten Code-Editor zu Grunde liegt. Das CodeEditorViewModel beinhaltet einen String, welcher den Code enthält. Dieser ist per Datenbindung an den Text des Code-Editors gebunden. Zusätzlich enthält CodeEditorViewModel entweder eine Referenz auf die zu bearbeitende Node, oder die zu bearbeitende Function. Eine Aufgabe des CodeEditorViewmodels ist es, den im Editor eingegebenen Code synchron mit dem Code in der jeweiligen Node oder Function zu halten. 
\newline
Damit der Benutzer die selbst definierten Funktionen verwalten kann, existiert zusätzlich ein Funktions-Editor, in dem neue Funktionen angelegt, gelöscht oder bearbeitet werden können. Für diesen Editor wird ein eigenes ViewModel namens FunctionCollectionViewModel verwendet. Es beinhaltet eine Referenz auf die Liste der Funktionen, die sich im FlowDiagramViewModel befinden und wendet das Ändern, Löschen oder Hinzufügen von Funktionen auf diese Liste an.

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/FlowDiagramViewModelUML.png}
	\caption[Klassenstruktur der ViewModelSchicht]{Zu sehen sind die beiden ViewModel FlowDiagramViewModel und CodeEditorViewModel. Ersteres verwaltet Listen mit den Node-, Connector-, Variable- und Function-Instanzen, die beim Instanzieren der Klasse Flow benötigt werden. Letzteres übernimmt die Präsentationslogik für den Code-Editor, indem es Referenzen auf die zu bearbeitenden Node- und Functioninstanzen verwaltet und den Code in Form eines Strings nach für die Datenbindung bereit stellt.}
	\label{fig:UML:FlowViewModel}
\end{figure}

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/MVVMSequence.png}
	\caption[Kommunikationsablauf zwischen View- und ViewModel-Schicht]{Der Ablauf der Kommunikation zwischen der View- und der ViewModel-Schicht. Interagiert der Benutzer mit dem View, zum Beispiel durch das Hinzufügen von Nodes oder Connectors, werden entsprechende Events ausgelöst. Auf diese reagiert die abgeleitete View-Klasse FlowDiagramControl und aktualisiert ihre Daten mit den Objekten. Das ViewModel erhält die aktualisierten Daten über die Datenbindung des Frameworks und kann so, wenn der Benutzer das Konversationsrouting speichern möchte, die Klasse Flow der Model-Schicht instanzieren.}
	\label{fig:UML:MVVMSequence}
\end{figure}

\subsection[Die View-Schicht]{Die View-Schicht: FlowDiagramView, FlowDiagramControl, FlowDiagramItem}
Die View-Schicht übernimmt alle Elemente der grafischen Benutzeroberfläche, die der Benutzer unmittelbar sieht und mit denen er interagiert. Das Hauptelement der View-Schicht ist die Klasse FlowDiagramView, welche von der Framework-Klasse UserControl erbt. FlowDiagramView umfasst alle Windows Forms-Controls, die zum Darstellen des Editors benötigt werden und übernimmt zusätzlich die Konfiguration des MVVM-Frameworks während der Initialisierungsphase der Benutzeroberfläche.
\newline  
Das wichtigste Element der Benutzeroberfläche ist das Control FlowDiagramControl, welches  die abstrakte Syntax des Konversationsroutings darstellt. In Abbildung \ref{fig:UML:FlowView} ist schematisch dargestellt, wie es in die Klassenstruktur der View-Schicht eingefügt ist. Es basiert auf der Devexpress-Klasse DiagramControl, die es Benutzern ermöglicht, Diagramme mit geometrischen Formen und Verbindungen zu gestalten. FlowDiagramControl ist von dieser Klasse abgeleitet und erweitert sie um die Fähigkeit, ein Modell der DSL per Datenbindung darzustellen. Dafür sind in FlowDiagramControl Listen vom Typ ObservableCollection als Membervariablen angelegt, welche die Elemente des aktuellen DSL-Modells enthalten. Diese Listen existieren analog zur Klasse FlowDiagramViewModel aus Abschnitt \ref{subsec:Die Viewmodel-Schicht}. Durch die Datenbindung zwischen FlowDiagramControl und FlowDiagramViewModel werden die Inhalte aller Listen synchron gehalten. Die Aufgabe von FlowDiagramControl ist es, auf Interaktionen des Benutzers so zu reagieren, dass die Listen entsprechend aktualisiert werden. Zu diesem Zweck ist diese Klasse in einigen Aspekten gegenüber DiagramControl wie folgt angepasst und spezialisiert.
\newline
Für ein Devexpress-DiagramControl kann eine Auswahl von sogenannten Stencils, also für das Diagramm verfügbare Formen, dem Control hinzugefügt werden. Jedes Stencil verfügt über ein Objekt der Klasse FactoryItemTool, welches eine Instanz vom Interface-Typ IDiagramItem erzeugt. Wird ein Stencil aus der Toolbox in das Diagramm per Drag and Drop eingefügt, erzeugt das zugehörige FactoryItemTool ein entsprechendes Objekt, welches IDiagramItem implementiert. IDiagramItem stellt Methoden zu Verfügung, die DiagramControl benötigt um Objekte grafisch darzustellen. FlowDiagramControl ist so konfiguriert, dass jeder Node-Subtyp, also jede Instruktion der DSL, als eigenes Stencil dem Control hinzugefügt ist. Die Instanzen von FactoryItemTool für jedes dieser Stencil erzeugen ein Objekt vom Typ FlowDiagramItem. FlowDiagramItem ist die visuelle Repräsentation einer Konversationsrouting-Instruktion und erbt von der Devexpress-Klasse DiagramContainer, welche IDiagramItem implementiert. FlowDiagramItem besitzt eine Referenz auf ein Objekt vom Typ Node. Im Konstruktor von FlowDiagramItem wird das visuelle Erscheinungsbild einer einzelnen Instruktion initialisiert: Dabei werden Klassen vom Devexpress-Typ DiagramShape zu einer Liste hinzugefügt, welche dann vom Framework gezeichnet werden und verschiedene geometrische Formen annehmen können. FlowDiagramItem fügt der Liste von DiagramShapes ein blaues Rechteck für den Körper, ein weißes Rechteck für die Instruktionsüberschrift sowie kleinere rote und grüne Rechtecke für Instruktionsaus- und Eingänge hinzu. Die Rechtecke für Ein- und Ausgänge werden durch die eigens implementierten Klassen FlowDiagramInputPort und FlowDiagramOutputPort repräsentiert. Beide Klassen erben von der gemeinsamen Basis-Klasse FlowDiagramPort, welche wiederum DiagramContainer erweitert. Diese Port-Klassen bestimmen das visuelle Erscheinungsbild der zu zeichnenden Rechtecke und ermöglichen es FlowDiagramItem, Ausgänge zu beschriften oder aus- und einzublenden. Wieviele Aus- und Eingänge die jeweilige zu visualisierende Instruktion besitzt, wird aus dem Subtyp der Node-Referenz ermittelt, die in FlowDiagramItem hinterlegt ist.
\newline
Wird nun vom Benutzer ein Stencil aus der Toolbox ausgewählt und in das Modellierungsfenster gezogen, erzeugt die zugehörige Instanz von FactoryItemTool ein FlowDiagramItem. Dieses FlowDiagramItem wird mit einer Referenz auf eine neu erstellte Instanz des Node-Subtyps der ausgewählten Instruktion initialisiert. DiagramControl löst dann ein Event aus, das signalisiert, dass sich die Liste an Diagramm-Elementen verändert hat. FlowDiagramControl reagiert auf dieses Event seiner Basisklasse, indem es die Node-Referenz aus dem hinzugefügten FlowDiagramItem zu der Liste der Nodes hinzufügt, die per Datenbindung an das FlowDiagramViewModel gebunden sind. Umgekehrt reagiert FlowDiagramControl auch auf Events, die ausgelöst werden, wenn die Liste der Nodes durch das ViewModel verändert wird. In diesem Fall wird ein neues FlowDiagramItem mit einer Referenz auf die hinzugefügte Node erzeugt, sodass diese Node auf der Benutzeroberfläche zu sehen ist. Analog verhält sich das System wenn Nodes oder FlowDiagramItems gelöscht werden, nur dass in diesem Fall Elemente entfernt werden.
\newline
Um die Verbindungen zwischen Instruktionen zu modellieren, wird ähnlich vorgegangen. FlowDiagramControl überschreibt die geerbte Methode CreateConnector, welche vom Framework aufgerufen wird, wenn der Benutzer eine Verbindung zwischen Diagrammelementen zieht. Die Methode liefert eine Instanz von FlowDiagramConnector zurück, in der eine Referenz auf einen Connector der Model-Schicht hinterlegt ist. Wird ein FlowDiagramConnector dem Diagramm hinzugefügt, wird über ein entsprechendes Event ein neuer Connector der per Datenbindung synchronisierten Liste hinzugefügt. In FlowDiagramViewModel wird dementsprechend ebenfalls ein neuer Connector hinzugefügt und die Input- und Output-Referenzen der im Connector betroffenen Ein- und Ausgänge werden aktualisiert. Wird ein Connector der Modelschicht hinzugefügt, läuft der Prozess rückwärts ab. Das heißt, über die synchronisierte Liste der Connector-Instanzen wird ebenfalls im FlowDiagramControl ein Event ausgelöst, so dass das Control dem Diagramm einen neuen FlowDiagramConnector hinzufügen kann. Beim Entfernen von Connector-Instanzen wird der Prozess gleich behandelt, nur dass Referenzen entsprechend entfernt werden.      

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/FlowViewUML.png}
	\caption[Klassenstruktur der View-Schicht]{Abgebildet ist ein Teil der View-Schicht. Zu sehen ist FlowDiagramView, welche über eine Instanz von FlowDiagramControl verfügt. FlowDiagramControl beinhaltet die Klassen FlowDiagramItem und FlowDiagramConnector, welche die Node- und Connector-Instanzen der Model-Schicht visualisieren. Über das ViewModel erhält FlowDiagramControl per Datenbindung Zugriff die zu visualisierenden Daten.}
	\label{fig:UML:FlowView}
\end{figure}


\section{Transformation}
\label{sec:Transformation}

\subsection{Konzept}
Die Transformation ist der Schritt in der Verarbeitungskette, in der aus einem semantischen Modell, welches in der Form der C\#-Datenstruktur aus Abschnitt \ref{subsec:Die Model-Schicht} vorliegt, die MSIL-Syntax generiert wird. Diese kann anschließend kompiliert und ausgeführt werden. Ein Modell wird auf eine zu generierende Klasse abgebildet, welche das gewünschte Verhalten des Modells implementiert. Diese Klasse erbt von einer abstrakten Basisklasse mit dem Namen ACDCallRoutingBehaviorBase, welche die abstrakte Methode StartAsync zur Verfügung stellt. Die vom Transformationsalgorithmus generierte Klasse implementiert StartAsync so, dass beim Aufruf das vom Benutzer spezifizierte Konversationsrouting abgespielt wird.
\newline 
Die Instruktionen des Konversationsroutings werden als Membermethoden der Klasse abgebildet. In der generierten Klasse existiert für jede Instruktion eine eigene Methode, deren Syntax das gewünschte Verhalten der Instruktion umsetzt. Der Bezeichner der Methode trägt den Namen der Instruktion, gefolgt von einer eindeutigen Identifikationsnummer, sodass mehrere Instruktionen des gleichen Typs bei der Generierung der zugehörigen Membermethoden nicht kollidieren. Manche Instruktionen müssen mit der zu routenden Konversation interagieren. Zu diesem Zweck steht der generierten Klasse eine API zur Verfügung, welche aus einer Instanz eines Interfaces namens IRoutedAcdCall besteht. Soll beispielsweise im Zuge einer Media Playback-Instruktion eine Audio-Datei abgespielt werden, kann Syntax generiert werden, welche die Methode PlayAudioAsync des Interfaces IRoutedAcdCall aufruft. 
\newline
Die Reihenfolge von Instruktionen in einem Konversationsrouting wird realisiert, indem generierte Methoden die Methoden ihrer Nachfolgeinstruktionen aufrufen. Angenommen, eine Branch-Instruktionen hat zwei Ausgänge: Der ''True``-Ausgang zeigt auf eine Media Playback-Instruktion während der ''False``-Ausgang auf die Terminate-Instruktion verweist. Aus diesen drei Instruktionen wird Syntax für drei Membermethoden generiert: Die Methode der Branch-Anweisung wertet den per Parameter übergebenen booleschen Ausdruck aus und ruft im True-Fall die Methode der Media Playback-Instruktion auf. Andernfalls wird die Methode der Terminate-Anweisung aufgerufen. Da es sich bei dem semantischen Modell um einen Graphen und keinen Baum handelt, kann es in Modellen zu Zyklen kommen. Solche potentiell endlose Konversationsroutings stellen ein Problem dar, denn sie führen zu einer endlosen Rekursion von Methodenaufrufen innerhalb der generierten Klasse. Das Problem wird gelöst indem eine Instruktion, die eine solche Rekursion starten würde, die nächste Instruktion in einem .NET-Task auf einem neuen Thread aufruft. Der aktuelle  Thread terminiert an der Stelle, an der der neue gestartet wird und eine endlose Rekursion wird vermieden.
\newline
Ein Modell kann vom Benutzer geschriebenen C\#-Code enthalten. Dieser muss in die generierte Klasse integriert werden, um ausführbar zu sein. Benutzerdefinierten Code jedoch einfach in die Syntax für Membermethoden einzufügen birgt Risiken. So hätte der Benutzer in seinem selbstgeschriebenen Code Zugriff auf alle Elemente der generierten Klasse, was zu Problemen führen kann, wenn er Methoden aufruft, die der generierten Klasse vorbehalten sind. Stattdessen wird Code des Benutzers wird in einer verschachtelten privaten Klasse gekapselt. Die geschachtelte Klasse trägt den Bezeichner ``UserCode'' und kapselt den benutzerdefinierten Code in eigenen Membermethoden. Die umfassende Klasse verfügt als Membervariable eine Instanz der Klasse UserCode und kann so den Code des Benutzers ausführen. Ist beispielsweise eine Script-Instruktion im Konversationsrouting integriert, wird der Skript-Code als eigene Membermethode in der Klasse UserCode angelegt. Die Skript-Instruktion wird zusätzlich als Membermethode der umfassenden Klasse abgebildet, welche dann die zugehörige Membermethode der Klasse UserCode aufruft. Da Scripte einen String zurückliefern (siehe \ref{subsec:Script}), gibt auch die in UserCode angelegte Membermethode einen String zurück, welcher dann in der aufrufenden Methode verwertet wird.
\newline
Vom Benutzer definierte Variablen und Funktionen sind in allen Instruktionen verwendbar, in denen der Benutzer eigenen Code angeben kann. Da Code des Benutzers in der Klasse UserCode abgebildet wird, werden auch die vom Benutzer angelegten Variablen und Funktionen in dieser Klasse jeweils als private Membervariablen und -funktionen angelegt. Die vordefinierten Variablen Skill und Language sind ebenfalls über die Klasse UserCode verfügbar: Sie sind als Properties von UserCode implementiert, die beim Benutzen per Getter und Setter über eine Instanz eines Interfaces namens IPredefinedVariables gesetzt werden. In der Routing Engine werden für Sprachen und Wissensbereiche interne Datenstrukturen verwendet. PredefinedVariable bildet die im System verfügbaren Sprachen und Wissensbereiche auf leicht handhabbare Strings ab, damit der Benutzer in seinen Skripten nicht mit ganzen Datenstrukturen arbeiten muss. Er setzt lediglich den String der gewünschten Variable und die Implementierung von IPredefinedVariable sucht die Datenstruktur mit dem gleichen Namen und setzt die entsprechende Variable.
\newline
Einige Aufrufe der API zur Interaktion mit dem eingehenden Ruf müssen den Programmfluss des Konversationsroutings zeitweise blockieren. So muss beispielsweise bei der Ausführung einer Media Playback-Instruktion darauf gewartet werden bis die Audiodatei zu Ende ist, bevor das Konversationsrouting weiter ausgeführt werden kann. In der Umsetzung wird zu diesem Zweck .NETs System der asynchronen Methodenausführung genutzt, welches den aktiven Thread der Routing Engine nicht blockiert (siehe \ref{subsec:Asynchrone Methodenausfuehrung}). Dazu werden Instruktionen, welche blockierende oder asynchrone API-Methoden aufrufen, selber auf asynchrone Methoden abgebildet. Die API-Methoden werden dann mithilfe des ``await''-Operators aufgerufen. Dies hat zur Folge, dass alle Methoden, die asynchrone Methoden im Zuge des Konversationsroutingablaufs aufrufen, diese ebenfalls mit ``await'' aufrufen und daher selber zu asynchronen Methoden werden. Folgt einer Set Variables-Instruktion beispielsweise eine Media Playback-Instruktion, so wird die Media Playback abbildende Methode mit einem await aufgerufen, während die Set Variable abbildende Methode selber als ``async'' deklariert wird. Der Aufrufer von Set Variables muss anschließend selber async werden, und so weiter. Dieses Muster zieht sich durch bis zu StartAsync-Methode, welche der Einstiegspunkt jedes Konversationsroutings ist.

\subsection{Beispiel}
\label{subsec:Beispiel}
Folgendes Beispiel soll die Transformation eines Konversationsroutings zu CIL-Syntax besser veranschaulichen. In Abb. \ref{fig:FlowToCode} ist ein einfaches Konversationsrouting dargestellt. 

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=0.7\textwidth]{img/FlowToCodeExample.png}
	\caption[Beispielhaftes Konversationsrouting zur Veranschaulichung der Transformation zu C\#-Syntax]{Beispielhaftes Konversationsrouting zur Veranschaulichung der Transformation zu CIL-Syntax.}
	\label{fig:FlowToCode}
\end{figure}

Die CIL-Syntax, die aus einem solchen Modell generiert wird, sieht in C\# dargestellt folgendermaßen aus:
\newpage

\lstinputlisting[breaklines=true, style=sharpc]{code/FlowToCode.cs}

Am Anfang des Listings steht die Deklaration einer öffentlichen Klasse namens GeneratedConversationBehavior, die von ACDCallRoutingBehavior erbt. Dies ist die Klasse, in der die Instruktionen als Membermethoden abgebildet werden. In dieser Klasse wird als nächstes eine private Klasse UserCode definiert. In UserCode sind die vordefinierten Variablen Skill und Language definiert, welche über ihre Getter und Setter auf eine private Instanz des Interfaces IPredefinedVariable zugreifen. Zusätzlich existiert eine Methode mit dem Namen ''BranchNode'' gefolgt von einer einzigartigen Kennnummer. Diese Methode enthält den vom Benutzer spezifizierten Ausdruck der für die Branch-Instruktion ausgeführt werden soll. Dementsprechend wird ein boolescher Wert zurückgeliefert. In diesem Beispiel vergleicht die Branch-Instruktion also die aktuelle Sprache, welche in der vordefinierten Variable Language gespeichert ist, mit dem String ``Deutsch''. 
\newline
Nach der Klasse UserCode folgt die eigentliche Implementierung des Konversationsroutings. Im Konstruktor der Klasse GeneratedConversationBehavior werden Abhängigkeiten zum Rest des Systems initialisiert: So wird mittels einer Instanz des Interfaces IRoutedAcdCall auf eine API zur Beeinflussung des eingehenden Anrufes zugegriffen. Die beiden Instanzen von IReadOnlyRepository stellen Methoden zur Verfügung, um auf die dem System bekannten Sprachen und Wissensbereiche zuzugreifen. Die drei Interface-Instanzen werden an die Basisklasse ACDCallRoutingBehaviorBase weitergeleitet. Im Konstruktor wird außerdem die private Instanz von UserCode initialisiert, welcher eine Instanz des PredefinedVariables-Interface aus der Basis-Klasse übergeben wird. Die restlichen Methoden der Klassen stellen die Abbildung der Instruktionen des Konversationsroutings dar. Die Start-Instruktion wird auf die Methode ``StartAsync'' abgebildet. Hier wird dem Routing gemäß sofort die Methode der Branch-Instruktion ``BranchNode'' aufgerufen, welche zuerst den vom benutzerdefinierten Code aus der Klasse UserCode aufruft, und das Ergebnis dessen als Bedingung in eine If-Abfrage einsetzt. Je nachdem welches Ergebnis zurückgeliefert wird, wird entweder die Methode der Deliver- oder der Terminate-Instruktion aufgerufen. ``TerminateNode'' ruft über die Membervariable Conversation der Basisklasse die API-Methode ``TerminateAsync'' auf, welche den eingehen Anruf beendet. Ähnlich läuft es in ``DeliverNode'' ab: Hier wird der Ruf mittels der API-Methode ``DeliverAsync'' der Ruf an einen Agenten zugestellt. Die dabei übergebene SIP-URI ist ein Parameter der Deliver-Instruktion.
\newline
Wird die Klasse GeneratedConversationBehavior nun von der RoutingEngine instanziert, und in einer Variable vom Typ ACDCallRoutingBehaviorBase gespeichert, kann über die Methode ``StartAsync'' das vom Benutzer gewünschte Konversationsrouting abgespielt werden.

\subsection{Umsetzung}
Das oben beschriebene Konzept zur Abbildung des semantischen Modells auf MSIL-Syntax wird von einer eigenen API realisiert, welche von der Routing Engine benutzt wird. Die grobe Klassenstruktur dieser API ist in Abbildung \ref{fig:UML:Transformator} zu sehen. Das Hauptelement ist die Klasse ConversationRoutingBehaviorGenerator, welche das Interface IBehaviorGenerator implementiert. Dieses Interface stellt die Methode GenerateAssembly zur Verfügung, welche ein semantisches Modell in Form einer Flow-Instanz entgegennimmt und eine MSIL-Assembly zurückliefert.  Dafür muss das semantische Modell jedoch zuerst in einen CIL-Syntaxbaum konvertiert werden. Zum Erstellen des Syntaxbaums wird die Methode BuildTree des Interfaces ISyntaxTreeBuilder verwendet, welches von der Klasse ConversationRoutingSyntaxTreeBuilder implementiert wird. BuildTree nimmt den Start-Knoten des Konversationsroutings sowie die benutzerdefinierten Variablen und Funktionen entgegen, und liefert einen kompilierbaren Syntaxbaum zurück. Der Syntaxbaum wird aus kleineren Einheiten zusammengesetzt: Auf der höchsten Ebene stehen die Klassendeklarationen, welche wiederum die Membermethodendeklarationen beinhalten. Wie diese Einheiten generiert werden, wird in den folgenden Abschnitten erläutert.

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/TransformatorUML.png}
	\caption[Klassenstruktur des Transformators]{Zu sehen ist die Klassenstruktur des Transformators. Die Hauptfunktionalitäten sind in den Interfaces abgebildet. Für die Implementierung dieser Methoden sind wiederum Funktionalitäten notwendig, die in anderen Interfaces definiert sind.}
	\label{fig:UML:Transformator}
\end{figure}
 

\subsubsection{Programmablauf}
\label{subsubsec:Programablauf}
Die Grundidee der Syntax-Zusammensetzung orientiert sich an einem Verfahren, das in \cite[S. 272f]{Voelter:13} als ''klassische Modell-Transformierung`` (engl. classical model transformation) bezeichnet wird: Das semantische Modell wird als Graph traversiert, während mit der Roslyn-API anhand des aktuell besuchten Knotens die passende Syntax generiert wird. Die Traversierung beginnt bei dem Start-Knoten des Konversationsroutings und besucht jede Instruktion des Graphen in der Reihenfolge einer Tiefensuche. Pro besuchter Instruktion wird die CLI-Syntax für eine Methode erstellt, welche das Verhalten der Instruktion umsetzt. Dort wo die Syntax die Methode der nachfolgenden Instruktion aufruft, wird diese Instruktion rekursiv besucht und die entsprechende Syntax für die abbildende Methode erstellt. Dies geht so lange weiter, bis eine Instruktion erreicht wird, die keine ausgehenden Verbindungen hat. An dieser Stelle ist der Rekursionsanker erreicht: Die Syntax für die letzte Instruktion des aktuellen Pfades wird generiert, der Liste der Membermethoden hinzugefügt, und der Aufruf der so generierten Methode an die Vorgänger-Instruktion zurückgeliefert. Diese kann den erhaltenen Aufruf nun in ihre eigene Syntax integrieren und ihren eigenen Aufruf an die eigene Vorgänger-Instruktion zurückliefern. Der Programmfluss kehrt auf diese Weise zurück zur Start-Instruktion, wo der letzte Methodenaufruf in die Methode ``StartAsync'' integriert wird. Zu diesem Zeitpunkt sind alle Methodendeklarationen erstellt und können der Klassendeklaration hinzugefügt werden. 
\newline
Da es sich bei einem Konversationsrouting auch um einen zyklischen Graph handeln kann, muss überprüft werden, ob ein solcher Zyklus im Routing vorhanden ist, um eine endlose Rekursion zu vermeiden. Daher wird während des rekursiven Ablaufs mit einem Stapelspeicher Protokoll geführt, welche Knoten des Routings schon besucht wurden. Beim Besuchen eines Knotens wird dieser auf den Stapel gelegt, beim Verlassen auf dem Rückweg der Rekursion wird dieser wieder entnommen. Wird ein Knoten besucht, der sich schon auf dem Stapelspeicher befindet, ist dieser Teil eines Zyklus und die Rekursion kann abgebrochen werden. Der zurückzuliefernde Methoden-Aufruf für diesen Knoten wird dann in einem neuen Thread ausgeführt. 
\newline
Die Struktur der Klassen, die den obenstehenden Algorithmus umsetzen, ist in Abbildung \ref{fig:UML:Transformator} zu sehen. Die Klasse FlowClassSyntaxBuilder implementiert die Schnittstelle IClassSyntaxBuilder, welche die Methode Build zur Verfügung stellt. Build nimmt eine Referenz auf die StartNode entgegen und liefert eine Klassendeklaration in Form einer SyntaxNode zurück. SyntaxNode ist ein Typ der Roslyn-API, welcher einen Knoten im CIL-Syntaxbaum repräsentiert. FlowClassSyntaxBuilder implementiert IFlowClassSyntaxBuilder indem es die Syntax für die zu generierende Klasse erstellt. Zum Erstellen der Membermethoden der Klasse wird das Interface IMethodSyntaxBuilder benutzt, welches von der Klasse MethodFlowSyntaxBuilder implementiert wird. IMethodSyntaxBuilder stellt Methoden zur Verfügung, welche Instanzen von Node oder Output entgegennehmen und eine Methodendeklaration zurückliefern, welche die übergebene Node abbilden soll. MethodFlowSyntaxBuilder implementiert diese Methoden mithilfe des rekursiven Prozesses, der weiter oben erläutert ist. Zu diesem Zweck implementiert die Klasse das Visitor-Pattern in Form des Interfaces IFlowNodeVisitor, in dem Methoden bereit gestellt werden, mit der alle Node-Subtypen sowie Inputs und Outputs besucht werden können. Bei dem Besuch einer Node muss je nach Subtyp bestimmte konkrete CIL-Syntax erstellt werden. Zu diesem Zweck existiert die abstrakte Klasse NodeSyntaxBuilder, von der pro Node-Subtyp eine Klasse erbt. Jeder dieser erbenden Klassen generiert die Syntax für den jeweiligen Node-Subtyp, für den sie zuständig ist. Dies geschieht in der überschriebenen Build-Methode der Basisklasse NodeSyntaxBuilder, welche die Syntax an MethodeFlowSyntaxBuilder zurückliefert. Der Ablauf ist in den Diagrammen \ref{fig:UML:TransformationSequence} und \ref{fig:UML:TransformationSequenceDetail} abgebildet und wird wie folgt abgewickelt:
\newline
Zuerst wird die Build-Methode für die StartNode-Referenz eines Flows aufgerufen, in der eine Instanz von StartNodeSyntaxBuilder erzeugt wird. Auf dieser Instanz wird nun die Methode Build aufgerufen, welcher neben der Referenz auf die StartNode auch die aufrufende Instanz von MethodFlowSyntaxBuilder übergeben wird. So kann StartNodeSyntaxBuilder für die Output-Instanz des StartKnotens MethodFlowSyntaxBuilder.Build aufrufen, in der wiederum die Visit-Methode aufgerufen wird. In der Visit-Methode wird nun Visit für die Input-Instanz aufgerufen, auf die der Output der StartNode verweist. Dort wird erneut Visit für die Node-Instanz aufgerufen, auf die wiederum der Input verweist. Die Rekursion setzt sich hier fort: Es wird ein NodeSyntaxBuilder für die aktuell besuchte Node instanziert und Build aufgerufen. Innerhalb der Build-Methode des NodeSyntaxBuilders wird jetzt die CIL-Syntax für die Instruktion in Form einer Liste von SyntaxNodes erstellt. Hat die aktuelle Node weitere Output-Instanzen, wird auch hier wieder MethodFlowSyntaxBuilder.Build für diese aufgerufen. Handelt es sich jedoch um eine Instruktion ohne Ausgänge, ist der Rekursionsanker erreicht. Der aktuelle NodeSyntaxBuilder liefert seine Liste mit SyntaxNodes an den MethodFlowSyntaxBuilder.Visit-Aufruf zurück. Dort werden die SyntaxNodes zu einer Methodendeklaration zusammengefasst und gespeichert. Der Visit-Aufruf kehrt zu seinem Build-Aufruf zurück und gibt als Rückgabe-Wert eine SyntaxNode zurück, in der ein Aufruf der eben erstellten Methodendeklaration enthalten ist. Dieser Aufruf kehrt zu dem Build-Aufruf des StartNodeSyntaxBuilder zurück, der die Syntax der StartNode generiert. Dort kann der Aufruf nun in die Syntax der eigenen Methode integriert werden, welche ihrerseits nun zu MethodFlowSyntaxBuilder zurückkehrt und der StartNode-Methode hinzugefügt wird. Der Prozess wird für alle Instruktionen eines Konversationsroutings durchgeführt, sodass am Ende die Programmfluss-Struktur aus Abschnitt \ref{subsec:Beispiel} erreicht ist.

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/TransformationSequence.png}
	\caption[Transformatinosablauf]{Grober Ablauf der Transformation als Sequenzdiagramm. Für den detailierten Ablauf in MethodFlowSyntaxBuilder siehe Abb. \ref{fig:UML:TransformationSequenceDetail} }
	\label{fig:UML:TransformationSequence}
\end{figure}

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=0.8\textwidth]{img/TransformationSequenceDetail.png}
	\caption[Transformationsablauf im Detail]{Ablauf der Generierung der Methodensyntax im Detail. Zu sehen ist der rekursive Ablauf des Verhaltens der Klasse MethodFlowSyntaxBuilder. In dem abgebildeten Diagramm ist der Ablauf zur Erstellung einer Syntax für ein Konversationsrouting  abgebildet, bei dem die Start-Instruktion direkt in die Terminate-Instruktion mündet. Das Beispiel ist so simpel gehalten um die Komplexität des Diagramms nicht unnötig zu erhöhen.}
	\label{fig:UML:TransformationSequenceDetail}
\end{figure}

\subsubsection{Nebenläufigkeit}
\label{subsubsec:Nebenlaeufigkeit}
Wie in Abschnitt \ref{sec:Transformation} beschrieben, werden manche Instruktionen auf asynchrone Methoden abgebildet, deren Asynchronität sich durch ein Konversationsrouting ziehen kann. Zum Zeitpunkt der oben beschriebenen Generierung der Programmablauf-Syntax muss bekannt sein, welche Instruktionen auf asynchrone Methoden abgebildet werden müssen. Daher wird vor der eigentlichen Generierung ein Vorverarbeitungsschritt ausgeführt, in dem alle Instruktionen des Konversationsroutings gesammelt werden, die auf asynchrone Methoden abgebildet werden müssen. Dafür wird das Konversationsrouting traversiert und asynchrone Instruktionen, sowie Instruktionen über die solche erreicht werden können, werden in einer Liste vermerkt, welche anschließend FlowClassSyntaxBuilder zur Verfügung gestellt wird. Die Bestimmung, ob eine Instruktion über einen Pfad im Routing eine asynchrone Instruktion erreichen kann, wird über die Berechnung der reflexiv-transitiven Hülle des Konversationsroutings, also einer Liste der direkten und indirekten Vorgänger aller Instruktionen, erreicht. So ist eine Instruktion asynchron, wenn sie in der reflexiv-transitiven Hülle in Relation mit einer anderen asynchronen Instruktion steht.

\subsubsection{Benutzerdefinierter Code}
Vom Benutzer spezifizierter Code wird in einer generierten Klasse namens UserCode gekapselt. Die Syntax für die Deklaration dieser Klasse wird von einer weiteren Implementierung des Interfaces IClassSyntaxBuilder namens UserCodeClassSyntaxBuilder übernommen. Da die UserCode-Klasse eine private Klasse ist, muss ihre Deklaration der Syntax für die Routing-steuernde Klasse hinzugefügt werden. Daher wird UserCodeClassSyntaxBuilder von FlowClassSyntaxBuilder benutzt. Die beiden Klassen ähneln sich in der Art und Weise, wie sie die Syntax für die jeweils eigene Klassendeklaration generieren: UserCodeClassSyntaxBuilder verwendet den gleichen rekursiven Ablauf zur Traversierung eines Konversationsroutings wie in Abschnitt \ref{subsubsec:Programablauf} beschrieben, nur dass dieser in seiner eigenen Klasse namens UserCodeMethodSyntaxBuilder implementiert ist. UserCodeMethodSyntaxBuilder behandelt beim Besuchen der Instruktionen nur Node-Subtypen, in denen benutzerspezifizierter Code zu finden ist. Für diese Knoten werden bestimmte NodeSyntaxBuilder-Subtypen instanziert, welche den Code des Benutzers parsen und in die zu erstellenden Methodendeklarationen der UserCode-Klasse einbetten. Außerdem bearbeitet UserCodeClassSyntaxBuilder auch die benutzerdefinierten Variablen und Funktionen. Diese werden der Reihe nach durchgegangen und die entsprechend generierte Syntax in Form von Methoden- und Variablendeklarationen wird der Klasse UserCode hinzugefügt. Die so entstehende UserCode-Klassendeklaration wird an FlowClassSyntaxBuilder übergeben, wo sie als private geschachtelte Klassendeklaration in die umfassende Klasse eingebettet wird.

\section{Modell-Validierung} 
Eine Aufgabe der DSL ist die Unterstützung des Benutzers durch das Vermeiden und schnelle Beseitigen von Fehlern. Dafür ist es von hoher Bedeutung, dem Benutzer Fehlerzustände in einem Konversationsrouting frühzeitig anzuzeigen, damit diese nicht bei der weiteren Spezifikation oder Transformation eines Konversationsroutings fortbestehen oder sich sogar vervielfachen. Zu diesem Zweck wird bei der Modellierung durch den Benutzer im Editor eine Modell-Validierung durchgeführt, bei der sogenannte Constraints überprüft werden. Bei Constraints handelt es sich laut [CITATION] um Regeln für die Gültigkeit eines DSL-Modells, welche dabei helfen, Fehler frühzeitig zu erkennen. Daher wird nach jeder Benutzer-Aktion, die das Konversationsrouting verändert, das aktuelle DSL-Modell analysiert und verschiedenen Prüfungen unterzogen. Diese Prüfungen stellen sicher, dass alle Constraints eingehalten werden und zeigen dem Benutzer im Falle eines Verstoßes eine entsprechende Fehlermeldung.
\newline
Die Modell-Validierung findet im Editor statt. Dort steht dem ViewModel eine Instanz des Interfaces IFlowValidator zur Verfügung, dessen Klassenstruktur im Diagramm \ref{fig:UML:FlowValidatorClassStructure} abgebildet ist. Die Klasse FlowValidator implementiert IFlowValidator, welche die Methode Validate zur Verfügung stellt. Validate nimmt ein semantisches Modell in Form einer Flow-Instanz entgegen und liefert eine Liste von FlowDiagnostics zurück, in denen Details zu auftretenden Fehlern wie zum Beispiel eine Fehlernachricht oder die betroffene Instruktion gespeichert sind. Zur Implementierung des Interfaces benutzt FlowValidator eine Liste von Instanzen des Interfaces IConstraintEvaluator, welche die Methode Evaluate bereitstellt. Klassen die IConstraintEvaluator implementieren nehmen in der Evaluate-Methode einen Flow entgegen und überprüfen diesen auf einen einzelnen Constraint. Verletzt das semantische Modell diesen Constraint, liefert Evaluate eine Liste mit FlowDiagnostics zurück. In der vorliegenden Implementierung sind vier ConstraintEvaluators umgesetzt: 
\begin{description}
\item[StartNodeExistsEvaluator] \hfill \\
Dieser ConstraintEvaluator überprüft, ob im semantischen Modell eine Start-Instruktion vorhanden ist.
\item[NoUnconnectedNodeExistsEvaluator] \hfill \\
Hier wird überprüft, ob Instruktionen existieren, deren Eingang unverbunden mit dem Rest des Konversationsroutings sind. Für jede unverbundene Instruktion wird eine Instanz von FlowDiagnostic zurückgeliefert, in der die betreffenden Nodes referenziert sind.
\item[NodeParametersAreValidEvaluator] \hfill \\
NodeParametersAreValidEvaluator überprüft, ob die Parameter von allen Nodes valide sind. So dürfen für Media Playback-Instruktion die angegebenen Audio-Dateien zum Beispiel nicht null sein. Verstößt eine Node gegen diese Constraints, wird sie in der zurückgelieferten Liste der FlowDiagnostics mit einer entsprechenden Warnung referenziert.
\item[UserCodeCompilesEvaluator] \hfill \\
Der UserCodeCompilesEvaluator prüft, ob der vom Benutzer geschriebene Code valide ist und kompiliert. Dafür muss das gesamte Modell transformiert und kompiliert werden. Daher besitzt UserCodeCompilesEvaluator eine Referenz auf eine ConversationRoutingBehaviorGenerator-Instanz, mit der bei jedem Aufruf von Evaluate das übergebene Modell transformiert wird. Anstatt einer Assembly wird von der Generator-Instanz allerdings das von Roslyn bereit gestellte semantische Modell der entstehenden CIL-Syntax angefordert. In diesem Modell in Form der Klasse SemanticModel speichert die Rosyln-API unter anderem alle Diagnostiken zur generierten Syntax. Existieren solche Diagnostiken nach der Modell-Transformation, werden diese von der Evaluate Funktion in FlowDiagnostics umgewandelt und zurück geliefert.
\end{description}
Wird im FlowViewModel des Editors nun eine Aktion des Benutzers registriert, wird FlowValidator.Validate aufgerufen. Dort werden auf allen Instanzen von IConstraintEvaluator die Evaluate-Methode aufgerufen, die zurückgelieferten FlowDiagnostics gesammelt, und diese anschließend zurückgeliefert. In FlowViewModel werden die FlowDiagnostics nun in einer Liste gespeichert, die per Datenbindung an die View-Schicht gebunden ist. Die FlowDiagnostics werden in einer List-Control angezeigt, welche die Diagnostics in Form einer Fehlermeldung visualisiert und bei einem Mausklick auf die betroffene Instruktion verweist. Zwischen FlowDiagramViewModel und CodeEditorViewModel werden die FlowDiagnostics mit einem Nachrichten-Service ausgetauscht, der vom Devexpress-Framework angeboten wird. CodeEditorViewModel kann so die Diagnostiken in einer eigenen Liste anzeigen und die Fehler rausfiltern, die nicht den vom Benutzer geschriebenen Code betreffen. Zusätzlich können Fehler so im Code des Benutzers rot unterstrichen werden.

\begin{figure} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{img/FlowValidatorClassStructure.png}
	\caption[Klassenstruktur der Modell-Validierung]{Abgebildet ist die Klassenstruktur der Modell-Validierung. Die Klasse FlowValidator benutzt eine Reihe von IConstraintEvaluator-Instanzen um die etwaige Constraint-Verstöße eines Modells als eine Liste von FlowDiagnostics an das ViewModel weiterzuleiten.}
	\label{fig:UML:FlowValidatorClassStructure}
\end{figure}