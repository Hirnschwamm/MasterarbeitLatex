\chapter{Implementierung}
\label{chap:Implementierung}

\section{Editor}
\label{sec:Editor}
Der Editor ist die Schnittstelle der DSL mit einem menschlichen Benutzer. Hier wird ein DSL-Modell durch Interaktion mit der konkreten Syntax erstellt oder bearbeitet. Die konkrete Syntax nimmt die Form eines Graphen an, der in Kapitel \ref{chap:Einleitung} beschrieben ist. Die Aufgabe des Editors ist es, die konkrete Syntax in abstrakte Syntax umzuwandeln. Während der Benutzer über die grafische Benutzeroberfläche mit der konkreten Syntax interagiert, also Instruktionen hinzufügt und Verbindungen zieht, wird Editor-intern die abstrakte Syntax geformt, welche der Benutzer nicht sieht (vgl. [CITATION Voelter, DSL Engineering, Abs 3.4, PDF Seite 68]. Die abstrakte Syntax ist durch eine C\#-Datenstruktur repräsentiert, welche für die weiteren Verarbeitungsschritte gespeichert wird (siehe Abschnitt \ref{sec:Verarbeitungsschritte}). In der Literatur wird die Datenstruktur, welche die abstrakte Syntax beinhaltet, auch semantisches Modell (engl. semantic model) genannt, vgl. [CITATION Martin Fowler, Domain Specific Languages] und wird daher im Folgenden auch so referenziert. Der Editor bildet also die abstrakte Syntax auf das semantische Modell ab. Diese Abbildung ist bidirektional: Wird das semantische Modell manipuliert, spiegelt die grafische Benutzeroberfläche dies in der konkreten Syntax wider.
\newline
Der Editor ist als eine Windows Forms-Anwendung umgesetzt und implementiert das Model-View-Viewmodel-Entwicklungsmuster (kurz MVVM). Ähnlich wie bei verwandten Entwurfsmustern wie zum Beispiel Model-View-Controller (MVC) geht es bei MVVM darum, die Darstellung einer Anwendung von ihrer Logik zu trennen. Dies geschieht durch eine Einteilung in drei verschiedene Schichten: Dem View, dem Viewmodel und dem Model. Die View-Schicht dient zur Darstellung der Anwendung und umfasst die Komponenten der grafischen Benutzeroberfläche. Sie erhält die nötigen Daten zur Darstellung vom Viewmodel über sogenannte Datenbindung (engl. Data Binding). Dabei werden Daten über ein Framework an einander gebunden und werden so vom System bei jeder Zustandsänderung synchron gehalten. Ändern sich also Daten im Viewmodel wird dies unverzüglich im View angezeigt. Das Viewmodel kümmert sich um die Präsentationslogik, das heißt es ist dafür zuständig, dem View Daten zur Verfügung zu stellen, welche über Datenbindungen angezeigt werden sollen. Dafür hat das Viewmodel Zugriff auf das Model, über dass die Daten zur Darstellung abgerufen werden. Im Model werden auch die Geschäftslogik sowie Speicher- und Lade-Aktionen ausgeführt. In .NET wird MVVM vor allem im Zuge der Windows Presentation Foundation eingesetzt, kann aber auch durch das Devexpress-Framework in Windows Forms-Anwendungen benutzt werden.
\newline
Im grafischen Editor der DSL werden die drei Schichten von MVVM durch verschiedene C\#-Klassen abgebildet, welche im Folgenden erläutert werden.
\subsection{Die Model-Schicht: Flow, Node, Input, Output, Connector, Variable, Function}
Die Model-Schicht beinhaltet die C\#-Datenstruktur, welche auch als semantisches Modell bezeichnet wird: Also das Objekt, welches in der weiteren Verarbeitung die abstrakte Syntax beschreibt. Das semantische Modell selbst weist kein programmitisches Verhalten auf, sondern ist eine reine Datenstruktur. Es besteht aus Instanzen von Klassen, welche die einzelnen Elemente der DSL modellieren und im Namespace ilogixx.ConversationFlow.Core definiert sind. Die Klassenstruktur der Model-Schicht ist in Abbildung [IMAGE UML MODEL] als UML-Diagramm aufgeführt und wird im Folgenden erläutert.
\newline
Instruktionen werden durch die abstrakte Klasse Node modelliert. Node besitzt eine Liste von Referenzen auf Output-Objekte, welche die Ausgänge einer Intruktion modellieren. Node hat ebenfalls eine Referenz auf ein Objekt vom Typ Input, welches den Eingang eines Knotens symbolisiert. Jede Art von Instruktion hat ihre eigene Subklasse, welche die Instruktionen aus Abschnitt \ref{sec:Sprachelemente} abbilden. Pro Ausgang einer Instruktion fügt der Konstruktor des Subtypen eine Referenz vom Typen Output der Referenzliste der Basisklasse hinzu. Im Konstruktor wird ebenfalls der Input spezifiziert: Hat die Instruktion einen Eingang, wird die Input-Referenz instanziert, andernfalls bleibt sie null. Viele Instruktionen haben die gleiche Anzahl an Ausgängen und einen Eingang. Daher existieren Subtypen, welche diese Initialisierungsarbeit übernehmen: Inputnode, für Instruktionen die einen Eingang haben, SingleOutputNode für Instruktionen die einen einzelnen Ausgang haben, und SingleThroughputNode, für Instruktionen die einen Ein- und einen einzelnen Ausgang haben. Alle elf Subtypen für die Instruktionen erben von diesen drei Klassen und passen dort wo nötig ihre Konfiguration an. Beispielsweise erbt DTMFCharacterNode von InputNode, und fügt der Output-Referenzliste dreizehn neue Outputs hinzu.
\newline
Die Klasse Input ist simpel: Sie zeigt über eine Referenz vom Typen Node auf ihre besitzende Instruktion. Die Klasse Output hingegen besitzt einige mehrere Daten. Sie speichert den Bezeichner des Ausgangs als String, einen weiteren String namens DisplayString, welcher vom Benutzer editiert werden kann und auf der Benutzeroberfläche angezeigt wird, einen Boolean namens Visible, welcher bestimmt ob der Ausgang in dem Rechteck der beinhaltenden Instruktion angezeigt wird, und eine Referenz vom Typ Input auf einen Eingang, falls der Ausgang mit einem solchen verbunden sein sollte. Durch letztere Input-Referenz sind die Verbindungen im Konversationsrouting zwischen den Instruktionen implizit gegeben. Dennoch existiert eine weitere Klasse namens Connector, welche eine Verbindung explizit definiert. Sie besitzt Referenzen auf die Input- und die Output-Instanz, welche verbunden sind.
\newline
Benutzerdefinierte Variablen und Funktionen sind über eigene Klassen abgebildet: Variable und Function. Variable besitzen einen Namen vom Typen String und einen Typen, der über einen Enum namens VariableType abgebildet ist, welcher die in \ref{subsec:Variablen} aufgezählten Typen beinhaltet. Function speichert ebenfalls einen Namen vom Typen String und einen Rückgabetyp, welcher über einen Enum mit Namen FunctionReturnType abgebildet ist. Zusätzlich wird der Funktionskörper mit Namen Body als String gespeichert. Parameter einer Funktion werden über eine Liste von Referenzen auf Objekte des Type Parameter modelliert. Ein Parameter besitzt, ähnlich wie die Klasse Variable, einen Namen als String und einen Typen als VariableType. Die Klasse Flow vereint alle oben genannten Klassen: Sie beinhaltet Listen mit Referenzen auf alle Nodes, Connectors, Functions und Variables. 

\subsection{Die Viewmodel-Schicht: FlowDiagramViewmodel, CodeEditorViewModel, FunctionCollectionEditorViewModel}
\label{subsec:Die Viewmodel-Schicht}
In der Viewmodel-Schicht werden die Klasseninstanzen der Model-Schicht so aufbereitet, dass die View-Schicht sie per Datenbindung repräsentieren kann. Die Viewmodel-Schicht reagiert auch auf Eingaben des Benutzers und manipuliert das zu Grunde liegende Model nach dessen Wünschen. 
\newline
Der Hauptbestandteil dieser Schicht ist die Klasse FlowDiagramViewmodel. Diese besitzt als Member-Variablen Listen auf Referenzen der Model-Komponenten Node, Connector, Variable und Function. Diese Listen sind vom .NET-Typ ObservableCollection, welche ein Event auslösen, falls der Liste Objekte hinzugefügt oder entfernt werden. Diese Listen sind per Devexpress-Datenbindung an die View-Schicht gekoppelt. Das heißt, wenn auf der View-Schicht Elemente des Models wie neue Node- oder Connector-Objekte hinzugefügt werden, aktualisieren sich die entsprechenden Listen im FlowDiagramViewmodel. Zusätzlich werden dadurch Events ausgelöst, auf die FlowDiagramViewModel reagiert. Dies wird dazu genutzt, die Referenzen zwischen den Klassen Input und Output aktuell zu halten: Wird ein Connector der Liste hinzugefügt, wird die Input-Referenz des im Connector referenzierten Outputs auf den Input gesetzt, der ebenfalls im Connector verlinkt ist. Der Vorgang wir rückgängig gemacht, wenn ein Connector entfernt wird. FlowDiagramViewModel übernimmt mittels der beiden Kommandos WriteToDisk und ReadFromDisk auch das Speichern und Laden von Konversationsroutings. Dafür wird mit den Listen der Node-, Connector-, Variable- und Function-Instanzen ein Flow-Objekt instanziert und mit Protobuf serialisiert. Pfade für die zu schreibenden beziehungsweise lesenden Dateien werden über Dialoge vom Benutzer abgefragt. Die Dialoge werden über vorgefertigte Serviceklassen angezeigt, welche das MVVM-Framework von Devexpress per Dependency Injection zur Verfügung stellt. 
\newline
FlowDiagramViewModel befindet sich hinter der Ansicht, in der der Benutzer sein Konversationsrouting modelliert. Einige Instruktionen benötigen jedoch die Möglichkeit, Code einzugeben. Zu diesem Zweck existiert ein weiteres ViewModel, welches dem eingebauten Code-Editor zu Grunde liegt. Das CodeEditorViewModel beinhaltet einen String, welcher den Code enthält. Dieser ist per Datenbindung an den Text des Code-Editors gebunden. Zusätzlich enthält das CodeEditorViewModel entweder eine Referenz auf die zu bearbeitende ScriptNode, oder die zu bearbeitende Function, welche den zu bearbeitenden Code enthält. Eine Aufgabe des CodeEditorViewmodels ist es den im Editor eingegebenen Code synchron mit dem code in der jeweiligen ScriptNode oder Function zu halten. 
\newline
Damit der Benutzer die selbst definierten Funktionen verwalten kann, existiert zusätzlich ein Funktions-Editor, in dem neue Funktionen angelegt, gelöscht oder bearbeitet werden können. Für diesen Editor existiert ebenfalls ein eigenes ViewModel: Das FunctionCollectionViewModel. Es beinhaltet eine Referenz auf die Liste der Funktionen, die sich im FlowDiagramViewModel befindet und wendet das Ändern, Löschen oder Hinzufügen von Funktionen auf diese Liste an.


\subsection{Die View-Schicht: FlowDiagramView, FlowDiagramControl, FlowDiagramItem}
Die View-Schicht übernimmt alle Elemente der grafischen Benutzeroberfläche, die der Benutzer unmittelbar sieht und mit denen er interagiert. Das Hauptelement der View-Schicht ist die Klasse FlowDiagramView, welche von der Framework-Klasse UserControl erbt. FlowDiagramView umfasst alle Windows Forms-Controls, die zum Darstellen des Editors benötigt werden und übernimmt zusätzlich die Konfiguration des MVVM-Frameworks während der Initialisierungsphase, in der die Benutzeroberfläche geladen wird.
\newline  
Das wichtigste Element der Benutzeroberfläche ist das Control FlowDiagramControl, welches  die abstrakte Syntax des Konversationsroutings darstellt. Es basiert auf der Devexpress-Klasse DiagramControl, die es Benutzern ermöglicht, Diagramme mit geometrischen Formen und Verbindungen zu gestalten. FlowDiagramControl ist von von dieser Klasse abgeleitet und erweitert sie um die Fähigkeit, ein Modell der DSL per Datenbindung darzustellen. Dafür sind in FlowDiagramControl Listen vom Typ ObservableCollection als Membervariablen angelegt, welche die Elemente des aktuellen DSL-Modells enthalten. Diese Listen existieren analog zur Klasse FlowDiagramViewModel aus Abschnitt \ref{subsec:Die Viewmodel-Schicht}. Durch die Datenbindung zwischen FlowDiagramControl und FlowDiagramViewModel werden die Inhalte aller Listen synchron gehalten. Die Aufgabe von FlowDiagramControl ist es, auf Interaktionen des Benutzers so zu reagieren, dass die Listen entsprechend aktualisiert werden. Zu diesem Zweck ist diese Klasse in einigen Aspekten gegenüber DiagramControl wie folgt angepasst und spezialisiert.
\newline
Für ein Devexpress-DiagramControl kann eine Auswahl von sogenannten Stencils, also für das Diagramm verfügbare Formen dem Control hinzugefügt werden. Jedes Stencil verfügt über ein Objekt der Klasse FactoryItemTool, welches eine Instanz vom Interface-Typ IDiagramItem erzeugt. Wird ein Stencil aus der Toolbox in das Diagram per Drag and Drop eingefügt, erzeugt das zugehörige FactoryItemTool ein entsprechendes Objekt, welches IDiagramItem implementiert. IDiagramItem stellt Methoden zu Verfügung, die DiagramControl benötigt um Objekte grafisch darzustellen. FlowDiagramControl ist so konfiguriert, dass jeder Node-Subtyp, also jede Instruktion der DSL, als eigenes Stencil dem Control hinzugefügt ist. Die Instanzen von FactoryItemTool für jedes dieser Stencil erzeugen ein Objekt vom Typ FlowDiagramItem. FlowDiagramItem ist die visuelle Repräsentation einer Konversationsrouting-Instruktion und erbt von der Devexpress-Klasse DiagramContainer, welche IDiagramItem implementiert. FlowDiagramItem besitzt eine Referenz auf ein Objekt vom Typ Node. Im Konstruktor von FlowDiagramItem wird das visuelle Erscheinungsbild einer einzelnen Instruktion initialisiert: Dabei werden Klassen vom Devexpress-Typ DiagramShape zu einer Liste hinzugefügt, welche dann vom Framework gezeichnet werden und verschiedene geometrische Formen annehmen können. FlowDiagramItem fügt der Liste von DiagramShapes ein blaues Rechteck für den Körper, ein weißes Rechteck für die Instruktionsüberschrift sowie kleinere rote und grüne Rechtecke für Instruktionsaus- und Eingänge hinzu. Wieviele Aus- und Eingänge die jeweilige zu visualisierende Instruktion besitzt sowie die Überschrift wird aus der Node-Referenz ermittelt.
\newline
Wird nun vom Benutzer ein Stencil aus der Toolbox ausgewählt und in das Modellierungsfenster gezogen, erzeugt die zugehörige Instanz von FactoryItemTool ein FlowDiagramItem. Dieses FlowDiagramItem wird mit einer Referenz auf eine neu erstellte Instanz des Node-Subtyps der ausgewählten Instruktion initialisiert. DiagramControl löst dann ein Event aus, das signalisiert dass sich die Liste an Diagramm-Elementen verändert hat. FlowDiagramItem reagiert auf dieses Event seiner Basisklasse, indem es die Node-Referenz aus dem hinzugefügten FlowDiagramItem zu der Liste der Nodes hinzufügt, die per Datenbindung an das FlowDiagramViewModel gebunden sind. Umgekehrt reagiert FlowDiagramControl auch auf Events, die ausgelöst werden, wenn die Liste der Nodes durch das ViewModel verändert wird. In diesem Fall wird ein neues FlowDiagramItem mit einer Referenz auf die hinzugefügte Node erzeugt, sodass diese Node auf der Benutzeroberfläche zu sehen ist. Analog verhält sich das System wenn Nodes oder FlowDiagramItems gelöscht werden, nur dass in diesem Fall Elemente entfernt werden.
\newline
Um die Verbindungen zwischen Instruktionen zu modellieren, wird ein ähnlicher Ansatz eingesetzt.


\section{Modell-Validierung} 
TODO

\section{Code-Generierung}
\label{sec:Code-Generierung}
TODO

\subsection{Herausforderungen}
TODO

\subsubsection{Programmablauf}
TODO

\subsubsection{User-Code}
TODO

\subsubsection{Nebenläufigkeit}
TODO

\subsection{Algorithmus}
TODO

\subsection{Einbindung von generiertem Code}
TODO